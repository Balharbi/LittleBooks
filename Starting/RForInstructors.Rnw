<<echo=FALSE,include=FALSE>>=
opts_chunk$set( fig.path="figures/RForInstructors-" ) 
set_parent('Master-Starting.Rnw')
set.seed(123)
require(fastR)
@

\chapter{What Instructors Need to Know about R}
\label{chap:RForInstructors}



\marginnote{You may find that some of these things are useful for your 
students to know as well. That will depend on the goals for your course
and the abilities of your students.  In higher level courses, much
of the material in this chapter is also appropriate for students.}
We recommend keeping the amount of \R\ that students need to learn
to a minimum, and choosing functions that support a formula interface whenever
possible to keep the required functions syntactically similar.
But there are some additional things that instructors (and some students)
should know about \R.  We outline some of these things in this chapter.


\section{Some Workflow Suggestions}
\label{sec:scripts}

Our workflow advice can be summarized in one short sentence: 

\begin{center}
\emph{Think like a programmer.}  
\end{center}

\BlankNote{We don't really think of our classroom use of \R\ as programming 
since we use \R\ in a mostly declarative rather than algorithmic way.}%
%
It doesn't take sophisticated programming skills to be good at using \R.  In fact,
most uses of \R\ for teaching statistics can be done working one step at a time,
where each line of code does one complete and useful task.  After inspecting the output
(and perhaps saving it for further computation later), one can proceed to the next 
operation.

Nevertheless, we can borrow from the collective wisdom of the programming community and
adopt some practices that will make our experience more pleasurable, more efficient, and 
less error-prone.

\begin{itemize}
  \item Store your code in a file.  %# rather than entering it at the prompt.

  It can be tempting to do everything in the console. But the console is ephemeral. 
  It is better to get into the habit of storing code in files.
  Get in the habit (and get your students in the habit) of working with \R\
  scripts and especially RMarkdown files.  

You can execute all the code in an \R\ script file using 
\Pointer{\R\ can be used to create executable scripts.  Option parsing and 
handling is supported with the \pkg{optparse} package.}

\Rindex{source()}
<<mr-source,eval=FALSE>>=
source("file.R") 
@

\Rstudio\ has additional options for executing some or all lines in a file. 
See the buttons in the tab for any \R\ script, RMarkdown or Rnw file.  
(You can create a new file in the main \tab{File} menu.)

If you work at the console's interactive prompt and later wish you had 
been putting your commands into a file, you can save your past commands with

\Rindex{savehistory()}
<<eval=FALSE,echo=TRUE>>=
savehistory("someRCommandsIalmostLost.R")
@
In \RStudio,
you can selectively copy portions of your history to a script file
(or the console) using the \tab{History} tab.

  \item Use meaningful names.

	  Rarely should objects be named with a single letter.  
	  
	  Adopt a personal convention regarding case of letters.  This will mean you
	  have one less thing to remember when trying to recall the name of an object.  For
	  example, in the \pkg{mosaic} package, all data frames begin with a
	  capital letter.  Most variables begin with a lower case letter (a few
	  exceptions are made for some variables with names that are well-known in
	  their capitalized form).

  \item
	  Adopt reusable idioms.

	  Computer programmers refer to the little patterns that recur throughout
	  their code as idioms.   For example, here is a ``compute, save, display'' 
	  idiom.
<<idiom, tidy=FALSE>>=
# compute, save, display idiom
footModel <- lm( length ~ width, data=KidsFeet ); footModel
# alternative that reflects the order of operations
lm( length ~ width, data=KidsFeet ) -> footModel; footModel
@

	  Often there are multiple ways to do the same thing in \R,
	  but if you adopt good programming idioms, it will be clearer to both you and
	  your students what you are doing.

  \item Write reusable functions.

	  Learning to write your own functions (see Section~\ref{sec:functions})
	  will greatly increase your efficiency and also help you understand better 
	  how \R\ works.  This, in turn, will help you debug your students error messages. 
	  (More on error messages in \ref{sec:error-messages}.) It also makes it
  possible for you to simplify tasks you want your students to be able to do in
  \R.  That is how the \pkg{mosaic} package originated -- as a collection of tools
  we had assembled over time to make teaching and learning easier.

  \item Comment your code.

\Rindex{\#}%
\myindex{comment character in R@comment character in {\sf R} (\texttt{\#})}%
It's amazing what you can forget.  The comment character in \R\ is \texttt{\#}.
If you are working in RMarkdown or Rnw files, you can also include nicely
formatted text to describe what you are doing and why.
\end{itemize}


\section{Primary \R\ Data Structures}
\label{sec:datastruct}

Everything in \R\ is an object of a particular kind and understanding the kinds 
of objects \R\ is using demystifies many of the messages \R\ produces and 
unexpected behavior when commands do not work the way you (or your students)
were expecting.  We won't attempt to give a comprehensive description of \R's object
taxonomy here, but will instead focus on a few important features and examples.


\subsection{Objects and Classes} % Modes and other attributes} %factors, numeric, character, etc.}
\myindex{object}
\myindex{class}
In \R, data are stored in objects.  Each \rterm{object} 
has a \emph{name}, \emph{contents}, and a \emph{class}.
The class of an object tells what kind of a thing it is.
The class of an object can be queried using \function{class()}
\Pointer{Many objects also have \emph{attributes} which contain
additional information about the object, but unless you are 
doing programming with these objects, you probably don't need to
worry too much about them.}%
%
\Rindex{class()}%
\Rindex{[ ]}%
\Rindex{[[ ]]}%

<<class>>=
class(KidsFeet)
class(KidsFeet$birthmonth)
class(KidsFeet$length)
class(KidsFeet$sex)
@
\begin{widestuff}
<<>>=
str(KidsFeet)                  # show the class for each variable
@
\end{widestuff}

\Rindex{KidsFeet}
From this we see that \dataframe{KidsFeet} is a data frame and that
the variables are of different types (integer, numeric, and factor).  These
are the kinds of variables you are most likely to encounter, although
you may also see variables that are logical (true or false) or character (text)
as well.
Factors are the most common way for categorical data to be stored in
\R, but sometimes the character class is better.  
\Pointer{One difference between a factor and a character is 
that a factor knows the possible values, even if some them
do not occur.  Sometimes this is an advantage (tallying empty
cells in a table) and sometimes it is a disadvantage (when factors
are used as unique identifiers).}%
The class of an object determines what things can be done with it
and how it appears when printed, plotted, or displayed in the console.


\subsection{Containers}

The situation is actually a little bit more complicated.  The
\variable{birthmonth} variable in \dataframe{KidsFeet} is not a single
integer but a collection of integers.  So we can think of \variable{birthmonth}
as a kind of container holding a number of integers.
\Pointer{Even when we only have a single integer, \R\ will treat it like
a container of integers with only one integer in it.}
There is more than one kind of container in \R.  The containers used 
for variables in a data frame are called \term{vectors}.
%There are important ways that \R\ has 
%been optimized to work with vectors since they correspond to variables 
%(in the sense of statistics).
\myindex{vector}%
The items in a vector are ordered (starting with 1) and must all be of the 
same type.  
\DiggingDeeper{In fact, they must all be of the same \emph{atomic} type.  
Atomic types are are the basic building blocks for \R.  It is not possible
to store more complicated objects (like data frames) in a vector.}

Vectors can be created using the \function{c()} function:
\Rindex{c()}
<<>>=
c(2, 3, 5, 7)
c("Abe", "Betty", "Chan")
c(1.2, 3.2, 4.5)
@
If you attempt to put different types of objects into a vector,
\R\ will attempt to convert them all to the same type of object.
\Caution{When reading data created in other software (like Excel)
or stored in CSV files, it is important to know how missing data
were indicated, otherwise, the code for missing data may be
interpreted as a character, causing all the other items in that
column to be converted to character values as well, and losing
the important information that some of the data were missing.}%
%
If it is unable to do so, it will generate an error.
<<tidy=FALSE>>=
x <- c(1, 1.1, 1.2); x   # integers converted to numeric
class(x)
y <- c(TRUE, FALSE, 0, 1, 2); y     # logicals converted to numeric
class(y)
z <- c(1, TRUE, 1.2, "vector"); z   # all converted to character
class(z)
@

\DiggingDeeper{
A factor can be ordered or unordered (which can affect how statistics
tests are performed but otherwise does not matter much).  The default 
is for factors to be unordered.
Whether the factors are ordered or unordered, the 
levels will appear in a fixed order -- alphabetical by default.  The 
distinction between ordered and unordered factors has to do with 
whether this order is meaningful or arbitrary.}%
%
Factors can be created by wrapping a vector with \function{factor()}:
\Rindex{factor()}
<<tidy=FALSE>>=
w <- factor(x); w
class(w)
@
Notice how factors display the \term{levels} (possible values) as well
as the values themselves.
When categorical data are coded as integers, it is important to remember 
to convert them to factors in this way for certain statistical procedures
and some plots.

Patterned integer or numeric vectors can be created using the \code{:} 
operator or the \function{seq()} function.
\Rindex{seq()}
<<>>=
1:10
seq(1, 10, by=0.5)
@

\newpage

\Rindex{[ ]}%
Individual items in a vector can be accessed or assigned using the 
square bracket operator:
<<>>=
w[1]
x[2]
y[3]
z[5]     # this is not an error, but returns NA (missing)
@
Missing values are coded as \code{NA} (not available).  Asking
for an entry ``off the end'' of a vector returns \code{NA}.
Assigning a value ``off the end'' of a vector results in the vector being
lengthened so that the new value can be stored in the appropriate location.
<<>>=
q <- 1:5
q
q[10] <- 10
q
@

\Pointer{\variable{letters} is a built-in character vector containing the
lower case letters.  \variable{LETTERS} contains capitals.}%

\R\ also provides some more unusual (but very useful) features for accessing 
elements in a vector.

\Rindex{letters[ ]}%
\Rindex{LETTERS[ ]}%
\begin{widestuff}
<<echo=FALSE>>=
OLD <- options( width=80 )
@
<<>>=
letters                       # alphabet
x <- letters[1:10]; x         # first 10 letters
x[2:4]                        # select items 2 through 4
x[2:4] <- c("X","Y","Z"); x   # change items 2 through 4
y <- (1:10)^2; y              # first 10 squares
y [ y > 20 ]                  # select the items greater than 20
@
<<echo=FALSE>>=
options(OLD)
@
\end{widestuff}
The last item deserves a bit of comment.  The expression inside
the brackets evaluates to a vector of logical values.
<<>>=
y > 20
@
The logical values are then used to select (true) or deselect (false)
the items in the vector, producing a new (and potentially shorter)
vector.  If the number of logical supplied is less than the length of the 
vector, the values are \term{recycled} (repeated).
<<>>=
y[ c(TRUE,FALSE) ]          # every other
y[ c(TRUE,FALSE,FALSE) ]    # every third
@
%If the recycling doesn't come out even, a warning is displayed.

\myindex{matrix}
\myindex{array}
A \rterm{matrix} is a 2-dimensional table of values that all have the 
same type.
As with vectors,
all of the items in a matrix must be of the same type.  But matrices
are two-dimensional -- each item is located in a row and column.
An \rterm{array} is a multi-dimensional version of a matrix.
Matrices and arrays are important containers for 
statistical work, but less likely to be encountered by beginners.  
<<>>=
M <- matrix(1:15, nrow=3); M    # a 3 x 5 matrix
@
The dimensions of an array, matrix or data frame can be obtained using
\function{dim()} or \function{nrow()} and \function{ncol()}.
\Rindex{dim()}%
\Rindex{nrow()}%
\Rindex{ncol()}%
\Rindex{matrix()}%
<<>>=
dim(M)
dim(KidsFeet)
nrow(KidsFeet)
ncol(KidsFeet)
@

\myindex{list}
Another commonly used container in \R\ is a list.  We have already seen a 
few examples of lists used as arguments to \pkg{lattice} plotting functions.
Lists are also ordered, but the items in a list can be objects of any type (they
need not all be the same type).
Behind the scenes, a data frame is a list of vectors with the restriction that
each vector must have the same \rterm{length} (contain the same number of items).

\Rindex{length()}
Lists can be created using the \function{list()} function.
<<>>=
l <- list( 1, "two", 3.2, list(1, 2)); l
length(l)          # Note: l has 4 elements, not 5
@
Items in a list can be accessed with the double square bracket (\code{[[ ]]}).
<<>>=
l[[1]]
@
Using a single square bracket (\code{[ ]}) instead returns a sublist rather 
than an element.  So \code{l[[1]]} is a vector, but \code{l[1]} is a list
containing a vector.
\Rindex{[[ ]]}%
<<>>=
l[1]
@

\Rindex{names()}%
Both vectors and lists can be named.  The names can be created when the vector 
or list is created or they can be added later.  Elements of vectors and lists can
be accessed by name as well as by position.
\Rindex{list()}
\Rindex{names()}
<<>>=
x <- c(one=1, two=2, three=3); x
y <- list(a=1, b=2, c=3); y
x["one"]
y["a"]
names(x)
names(x) <- c("A", "B", "C"); x
@


The access operators -- \code{[ ]} % for vectors, matrices, arrays, and data frames,
and \code{[[ ]]} for lists -- are actually \emph{functions} in \R.
This has some important consequences:
\begin{itemize}
  \item Accessing elements in a vector is slower than in a language like C/C++
  where access is done by pointer arithmetic.
  \item
  These functions also have named arguments, so you can see code like the following
\end{itemize}

<<"bracket-function">>=
M
M[5]
M[,2]                   # this is 1-d (a vector)
M[,2, drop=FALSE]       # this is 2-d (still a matrix)
@

\Rindex{data.frame()}%
Data frames can be constructed by supplying \function{data.frame()}
with the variables (as vectors):
<<attributes>>=
ddd <- data.frame(number=1:5, letter=letters[1:5])
@


%\section{More About Vectors}
%\label{sec:Rvectors}
%In Section~\ref{sec:generatingData} we learned how to generate some simple
%vectors.  Here we will learn about some of the operations and functions
%that can be applied to vectors.


\subsection{Vectorized functions}

\myindex{vectorized functions}
Vectors are so important in \R\ that they deserve some additional discussion.
Many \R\ functions and operations are ``vectorized'' and can be applied
not just to an individual value but to an entire vector, in which case
they are applied componentwise and return a vector of transformed values.  
Most of the commonly used functions from mathematics are available and work 
this way.
\Rindex{mean()}%
\Rindex{sd()}%
\Rindex{var()}%
\Rindex{median()}%
\Rindex{log()}%

<<vectors01,tidy=FALSE>>=
x <- 1:5; y <- seq(10, 60, by=10) 
x
y
y + 1                     # add 1 to each element
x * 10                    # multiply each element by 10
x < 3                     # check whether each is less than 3
x^2                       # square each element
sqrt(x)                   # square root of each element
log(x)                    # natural log
log10(x)                  # base 10 log
@

\noindent
Vectors can be combined into a matrix using \function{rbind()} 
or \function{cbind()}.  
This can facilitate side-by-side comparisons.
\Rindex{rbind()}%
\Rindex{cbind()}%
\Rindex{round()}%
\Rindex{signif()}%

<<vectors01a,tidy=FALSE>>=
# compare round() and signif() by binding row-wise into a matrix
z <- rnorm(5); z
rbind(round(z, digits=3), signif(z, digits=3))   
@


\subsection{Functions that act on vectors as vectors}

Other functions, including many statistical functions,
are designed to compute a single number (technically, a vector 
of length 1) from an entire vector.

<<vectors02, tidy=FALSE>>=
z <- rnorm(100)
# basic statistical functions; notice the use of names
c(mean=mean(z), sd=sd(z), var=var(z), median=median(z))  
range(z)                      # range returns a vector of length 2
x <- 1:10
c(sum=sum(x), prod=prod(x))   # sums and products
@

Still other functions return vectors that are derived from
the original vector, but not as a componentwise transformation.
\Rindex{sort()}
\Rindex{rank()}
\Rindex{diff()}
\Rindex{ediff()}
\Rindex{cumsum()}
\Rindex{cumprod()}
\Rindex{order()}


\begin{widestuff}
<<echo=FALSE>>=
OLD <- options(width=90)
@
<<vectors02a, tidy=FALSE>>=
z <- rnorm(5); z
sort(z); rank(z); order(z)              
x <- 1:9; x
rev(x)           # reverse x
diff(x)          # pairwise differences
ediff(x)         # pairwise differences w/out changing length
cumsum(x)        # cumulative sum
cumprod(x)       # cumulative product
@
<<echo=FALSE>>=
options(OLD)
@
\end{widestuff}
\label{r:sumprod}%

Whether a function is vectorized or treats a vector as a unit
depends on its implementation.  Usually, things are implemented 
the way you would expect.  Occasionally you may discover a function
that you wish were vectorized and is not.    
When writing your own functions, give some thought to whether they
should be vectorized, and test them with vectors of length greater than 1
to make sure you get the intended behavior.

\Rindex{sum()}%
\Rindex{prod()}%
\Rindex{cumsum()}%
\Rindex{cumprod()}%
\Rindex{cummin()}%
\Rindex{cummax()}%
\Rindex{diff()}%
\Rindex{rev()}%
\Rindex{sort()}%
\Rindex{rank()}%
\Rindex{order()}%
\Rindex{which()}%
\Rindex{any()}%
\Rindex{unique()}%
\Rindex{table()}%
\Rindex{paste()}%
\Rindex{na.omit()}%
\Rindex{pmin()}%
\Rindex{pmax()}%


\begin{widestuff}
\begin{center}
  Some additional useful functions\\
  
  \begin{longtable}{|p{1.2in}|p{4.0in}|}
  \hline
  \verb!cumsum()!

  \verb!cumprod()!

  \verb!cummin()!

  \verb!cummax()!
  &
  Returns vector of cumulative sums, products, minima, or maxima.
  \\ \hline
  \verb!pmin(x,y,...)!

  \verb!pmax(x,y,...)!
  &
  Returns vector of parallel minima or maxima where $i$th element is
  max or min of \verb!x[i]!, \verb!y[i]!, \dots.
  \\ \hline
  \verb!which(x)! 
  &
  Returns a vector of indices of elements of \verb!x! that are true.
  Typical use: \verb!which(y > 5)! returns the indices where elements
  of \verb&y& are larger than 5.
  \\ \hline
  \verb!any(x)! 
  &
  Returns a \verb!logical! indicating whether any elements of \verb!x! 
  are true.
  Typical use: \verb!if ( any(y > 5) ) { ... }!.
  \\ \hline
  \verb!na.omit(x)! & Returns a vector with missing values removed.
  \\ \hline
  \verb!unique(x)! & Returns a vector with repeated values removed.
  \\ \hline
  \verb!table(x)! & Returns a table of counts of the number of 
  occurrences of each value in \verb!x!.  The table is similar
  to a vector with names indicating the values, but it is not a vector.
  \\ \hline
  \verb!paste(x,y,...,!
  
  \verb!  sep=" ")! 
  & Pastes \verb!x! and \verb!y! together
  componentwise (as strings) with \verb!sep! between elements.
  Recycling applies.
  \\ \hline
  \end{longtable}
\end{center}
\end{widestuff}
